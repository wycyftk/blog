## 无重复字符的最长子串

`无重复字符的最长子串`题目是LeetCode的第三题，描述如下：

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

输入: "abcabcbb"  
输出: 3  
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。


**示例 2:**

输入: "bbbbb"  
输出: 1  
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3:**

输入: "pwwkew"  
输出: 3  
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。


## 分析

准确的分析题目的问题，才是解决问题的关键。

1. 问题：给定`一个字符串`，请你找出其中`不含有重复字符`的 `最长子串` 的`长度`。
2. 关键点：输入是字符串（String），输出是长度（Number），代码逻辑是找出不含重复字符的最长子串。因为输出的是长度，那么在算法过程中就只需要比较长度大小就可以。
3. 注意：子串与子序列不同，子串是必须连续的，区别见实例3的解释。

## 思路

### 1. 蛮力法

我们先使用蛮力法的来思考这个问题，先找到所有的`子串`，再从子串中找到满足条件的最长子串。以`"abcb"`为例来分析，思路如下：

1. 刚刚分解出三个条件，先从容易的`子串`开始，会分解为`"a"、"b"、"c"、"b"、"ab"、"bc"、"cb"、"acb"、"bcb"、"abcb"`；
2. 去掉`重复的子串`和`含重复字符`的子串，就剩下`"a"、"b"、"c"、"ab"、"bc"、"cb"、"acb"`；
3. 最后找到最长的子串`"abc"`，返回长度`3`；

在这个思路中，长度为n的字符串会分解成 `n + (n - 1) + (n - 2) + ... + 1 = (n + 1) * n / 2` 个子串。 在去掉`含有重复字符的子串`时，循环的次数（子串的数量 * 子串的长度）大大的增加。总的来说，蛮力法不仅要使用更多的空间来存储中间的变量，时间复杂度也会很高，代码实现起来也很麻烦。

### 2. 滑动窗口算法

蛮力法的特点在于遍历所有满足要求的结果集合，从中找到得到符合的结果。那有没有办法不用遍历所有的子串也能找到题目要求的结果呢？

当然是有的，这个方法就是**滑动窗口算法**，此算法通过改变起止下标方式在列表上寻找符合条件子列表。把子列表看成是一个窗口，当起止下标同时变大同样大小，那这个窗口就像在滑动；当起止下标改变不一样的时候，窗口不仅在滑动，窗口的大小也在改变。

> 滑动窗口的使用条件

使用这个算法需要满足两个条件：

1. **线性数据结构**； 
2. **结果来自于连续的子序列**

本题的问题寻找字符串的最长子串，字符串中的字母可以通过下标的方式取得，因此字符串可以看成是数组或链表，满足第一个条件；子串是连续的字符，正好也满足第二个要求（如果问题是最长子序列，那动态规划就是比较好的方案了）。

> 具体过程分析

下面的例子以字符`"pwwkew"`来分析，设输入字符为`s`，当前下标为`i`，当前子串为`subStr`、最大长度为`maxLength`。大致上的逻辑如下：

1. 读取字符`s.charAt(i)`，判断`s.charAt(i)`是否存在于`subStr`中，如果存在转2，否则转3；
2. 将`s.charAt(i)`添加到`subStr`末尾；
3. `subStr`截取自出现重复字符下标的下一位直到子串的末尾，执行2，比如说当前子串是`"pw"`，读取到`"w"`，则是将`"pw"`截取`w`的下一位；
4. 重复操作1直到读取完字符串

具体步骤见下图：

![image](https://github.com/wycyftk/images/raw/master/blog/lols.png)

## 代码实现

代码采用js实现，对过程中的两个地方进行了优化，一是当出现重复字符时才计数，二是不需要记录每一个不含重复字符的子串，只比较长度的大小。

```
var lengthOfLongestSubstring = function(s) {
  var subs = '', maxLength = 0;
  for (var i = 0; i < s.length; i++) {
    var index = subs.indexOf(s.charAt(i));
    if (index === -1) {
      subs += s.charAt(i);
    } else {
      // 当出现重复字符时才计数，减少计数次数
      maxLength = maxLength < subs.length ? subs.length : maxLength;
      subs = subs.substring(index + 1) + s.charAt(i);
    }
  }

  // 防止出现没有重复字符的情况没计数
  maxLength = maxLength < subs.length ? subs.length : maxLength;
  return maxLength;
};
```