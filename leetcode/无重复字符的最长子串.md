## 无重复字符的最长子串

`无重复字符的最长子串`题目是LeetCode的第三题，描述如下：

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

输入: "abcabcbb"  
输出: 3  
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。


**示例 2:**

输入: "bbbbb"  
输出: 1  
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3:**

输入: "pwwkew"  
输出: 3  
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。


## 分析

准确的分析题目的问题，才是解决问题的关键。

1. 问题：给定`一个字符串`，请你找出其中`不含有重复字符`的 `最长子串` 的`长度`。
2. 关键点：输入是字符串（String），输出是长度（Number），代码逻辑是找出不含重复字符的最长子串。因为输出的是长度，那么在算法过程中就只需要比较长度大小就可以。
3. 注意：子串与子序列不同，子串是必须连续的，区别见实例3的解释。

## 思路

### 1. 蛮力法

我们先使用蛮力法的来思考这个问题，先找到所有的`子串`，再从子串中找到满足条件的最长子串。以`"abcb"`为例来分析，思路如下：

1. 刚刚分解出三个条件，先从容易的`子串`开始，会分解为`"a"、"b"、"c"、"b"、"ab"、"bc"、"cb"、"acb"、"bcb"、"abcb"`；
2. 去掉`重复的子串`和`含重复字符`的子串，就剩下`"a"、"b"、"c"、"ab"、"bc"、"cb"、"acb"`；
3. 最后找到最长的子串`"abc"`，返回长度`3`；

在这个思路中，长度为n的字符串会分解成 `n + (n - 1) + (n - 2) + ... + 1 = (n + 1) * n / 2` 个子串。 在去掉`含有重复字符的子串`时，循环的次数（子串的数量 * 子串的长度）大大的增加。总的来说，蛮力法不仅要使用更多的空间来存储中间的变量，时间复杂度也会很高，代码实现起来也很麻烦。

### 2. 滑动窗口算法

蛮力法的特点在于遍历所有满足要求的结果集合，从中找到得到符合的结果。那有没有办法不用遍历所有的子串也能找到题目要求的结果呢？

当然是有的，这个方法就是**滑动窗口算法**，此算法通过改变起止下标方式在列表上寻找符合条件子列表。把子列表看成是一个窗口，当起止下标同时变大同样大小，那这个窗口就像在滑动；当起止下标改变不一样的时候，窗口不仅在滑动，窗口的大小也在改变。

> 使用条件

使用这个算法需要同时满足两个条件：

1. **线性数据结构**； 
2. **结果来自于连续的子序列**

本题的问题寻找字符串的最长子串，字符串中的字母可以通过下标的方式取得，因此字符串可以看成是数组或链表，满足第一个条件；子串是连续的字符，正好也满足第二个要求（如果问题是最长子序列，那动态规划就是比较好的方案了）。

只要满足上面两个条件，就可以使用滑动窗口的算法了。但是本题的话，还需要注意的就是**窗口的大小**。由于不知道最长子串具体的长度，那窗口的大小就是动态变化的。在编写代码的时候，尤其要注意窗口大小变化的条件，这也是最容易犯错的地方。

> 应用场景

在leetcode中出现的题目，也可以使用滑动窗口算法解决的题目有：3. 无重复字符的最长子串、219.存在重复元素II、209.长度最小的子数组、438. 找到字符串中所有字母异位词。当然还有很多别的题目也可以使用这个算法，就不一一列举了。

另外，学过网络的同学，应该知道TCP的流量控制中也有滑动窗口算法的使用，有兴趣的同学可以点击[了解一下](https://www.zhihu.com/question/32255109)。

> 解题过程分析

下面的例子以字符`"pwwkew"`来分析，设输入字符为`s`，当前下标为`i`，当前子串为`subStr`、最大长度为`maxLength`。大致上的逻辑如下：

1. 读取字符`s.index(i)`，判断`s.index(i)`是否存在于`subStr`中，如果存在转2，否则转3；
2. 将`s.index(i)`添加到`subStr`末尾；
3. `subStr`截取自出现重复字符下标的下一位直到子串的末尾，执行2，比如说当前子串是`"pw"`，读取到`"w"`，则是将`"pw"`截取`w`的下一位；
4. 重复操作1直到读取完字符串

具体步骤见下图：

![image](https://github.com/wycyftk/images/raw/master/blog/lols.png)

## 代码实现

```
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        subStr = ''
		l = len(s)
        ww = l
		if l == 0 or 1 == 1
			return l
		# 控制窗口大小变化
        for i in range(0, ww):
			# 窗口宽度为ww, 窗口滑动范围
            for j in range(0, l - ww + 1):
                subStr = s[j:j + ww]
				# 判断当前字符在子串出现次数
                for c in subStr:
                    if subStr.count(c) > 1:
                        break
                    elif subStr.index(c) == len(subStr) - 1:
                        return len(subStr)
			ww = ww - 1
```

代码采用py实现，对上述解题过程中的两个地方进行了优化，一是当出现重复字符时才计数，二是不需要记录每一个不含重复字符的子串，只比较子串长度的大小。

时间复杂度：一层for循环，外加判断字符是否出现在字符串里，所以**时间复杂度是O(n²)**

空间复杂度：存储变量的空间始终没变，所以**空间复杂度是O(1)**

```
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        subStr = ''
        maxLength = 0
        for c in s:
            if c not in subStr:
                subStr+=c
            else:
                # 当出现重复字符时才计数，减少计数次数
                mx = max(maxLength, len(subStr))
                subStr = subStr[subStr.index(c) + 1:] + c
        # 当出现重复字符时才计数，减少计数次数
        maxLength = max(maxLength, len(subStr))
        return maxLength
```

